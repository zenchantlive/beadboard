# Memory Fabric Workflow (bd-native)

Goal: keep memory durable, queryable, and behavior-changing without graph noise.

Core model:
1. Domain Anchors (open epic)
- Purpose: index and discovery root per domain
- Labels: memory,memory-anchor,<domain>
- Example domains: memory-arch,memory-workflow,memory-ux,memory-agent,memory-reliability

2. Canonical Memory Nodes (closed decision)
- Purpose: ratified reusable rules/patterns
- Labels: memory,mem-canonical,mem-hard|mem-soft,<domain>
- Lifecycle: create -> ratify -> close

3. Execution Contracts (open task or decision)
- Purpose: temporary enforcement wrapper for hard constraints only
- Labels: memory-contract,mem-hard,<domain>
- Lifecycle: attach to active work while unresolved, close when satisfied

Required lifecycle:
1) Propose memory node
- Create as decision bead using strict template fields (Scope, Out of Scope, Rule, Rationale, Failure Mode)

2) Ratify memory node
- Add acceptance checks and metadata JSON
- Close with explicit reason: Ratified canonical memory

3) Index memory node
- Relate canonical node to exactly one primary domain anchor
  bd dep relate <anchor-id> <memory-id>

4) Inject memory into execution
- At task start, query by domain and attach relevant nodes via relates_to
- Promote only mem-hard constraints to blocker contracts

5) Evolve memory safely
- Do not rewrite historical canonical truth
- Create a new canonical node and link lineage:
  bd supersede <old-memory-id> --with <new-memory-id>

Non-negotiables:
- No direct writes to .beads/issues.jsonl
- No markdown-only memory source of truth
- No blanket blocker links for all memories
- Evidence before completion claims
